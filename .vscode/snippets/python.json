{
  "FastAPI Service": {
    "prefix": "fastapi-service",
    "body": [
      "from fastapi import FastAPI, Depends, HTTPException",
      "from pydantic import BaseModel, validator",
      "import logging",
      "import asyncio",
      "",
      "logger = logging.getLogger(__name__)",
      "",
      "app = FastAPI(title=\"${1:ServiceName}\", version=\"1.0.0\")",
      "",
      "class ${2:RequestModel}(BaseModel):",
      "    ${3:fields}",
      "    ",
      "    @validator('${4:field}')",
      "    def validate_${4:field}(cls, v):",
      "        if not v or len(v.strip()) < 3:",
      "            raise ValueError('${4:field} must be at least 3 characters')",
      "        return v.strip()",
      "",
      "class ${5:ResponseModel}(BaseModel):",
      "    ${6:response_fields}",
      "",
      "@app.get(\"/health\")",
      "async def health_check():",
      "    return {\"status\": \"healthy\", \"service\": \"${1:ServiceName}\"}",
      "",
      "@app.post(\"/${7:endpoint}\", response_model=${5:ResponseModel})",
      "async def ${8:function_name}(",
      "    request: ${2:RequestModel},",
      "    current_user: User = Depends(get_current_user)",
      ") -> ${5:ResponseModel}:",
      "    try:",
      "        logger.info(\"${8:function_name} called\", {",
      "            \"user_id\": current_user.id,",
      "            \"request_data\": request.dict()",
      "        })",
      "",
      "        # TODO: Implement service logic",
      "        ",
      "        result = ${9:result}",
      "        ",
      "        logger.info(\"${8:function_name} completed\", {",
      "            \"user_id\": current_user.id,",
      "            \"result_id\": result.id if hasattr(result, 'id') else None",
      "        })",
      "",
      "        return result",
      "    except ValidationError as e:",
      "        logger.error(\"Validation error in ${8:function_name}\", {\"error\": str(e)})",
      "        raise HTTPException(status_code=400, detail=str(e))",
      "    except Exception as e:",
      "        logger.error(\"${8:function_name} failed\", {\"error\": str(e)})",
      "        raise HTTPException(status_code=500, detail=\"Internal server error\")",
      "",
      "if __name__ == \"__main__\":",
      "    import uvicorn",
      "    uvicorn.run(app, host=\"0.0.0.0\", port=${10:3000})"
    ],
    "description": "Create a FastAPI service with proper error handling and validation"
  },
  "Database Model": {
    "prefix": "db-model",
    "body": [
      "from sqlalchemy import Column, String, DateTime, Boolean, Text, Integer, ForeignKey",
      "from sqlalchemy.dialects.postgresql import UUID, JSONB",
      "from sqlalchemy.ext.declarative import declarative_base",
      "from sqlalchemy.orm import relationship",
      "from sqlalchemy.sql import func",
      "import uuid",
      "",
      "Base = declarative_base()",
      "",
      "class ${1:ModelName}(Base):",
      "    __tablename__ = '${2:table_name}'",
      "",
      "    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)",
      "    ${3:fields}",
      "    created_at = Column(DateTime(timezone=True), server_default=func.now())",
      "    updated_at = Column(DateTime(timezone=True), onupdate=func.now())",
      "",
      "    def __repr__(self):",
      "        return f\"<${1:ModelName}(id={self.id})>\"",
      "",
      "    def to_dict(self):",
      "        return {",
      "            'id': str(self.id),",
      "            ${4:dict_fields}",
      "            'created_at': self.created_at.isoformat() if self.created_at else None,",
      "            'updated_at': self.updated_at.isoformat() if self.updated_at else None,",
      "        }"
    ],
    "description": "Create a SQLAlchemy database model"
  },
  "Service Class": {
    "prefix": "service-class",
    "body": [
      "import logging",
      "from typing import List, Optional, Dict, Any",
      "from sqlalchemy.orm import Session",
      "from pydantic import BaseModel",
      "",
      "logger = logging.getLogger(__name__)",
      "",
      "class ${1:ServiceName}Service:",
      "    def __init__(self, db: Session):",
      "        self.db = db",
      "",
      "    async def ${2:method_name}(self, ${3:params}) -> ${4:ReturnType}:",
      "        try:",
      "            logger.info(\"${2:method_name} started\", {",
      "                \"${5:log_params}\"",
      "            })",
      "",
      "            # TODO: Implement service logic",
      "            ",
      "            result = ${6:result}",
      "            ",
      "            logger.info(\"${2:method_name} completed\", {",
      "                \"${7:result_log}\"",
      "            })",
      "",
      "            return result",
      "        except Exception as e:",
      "            logger.error(\"${2:method_name} failed\", {",
      "                \"error\": str(e),",
      "                \"${5:log_params}\"",
      "            })",
      "            raise",
      "",
      "    async def ${8:method_name_2}(self, ${9:params_2}) -> ${10:ReturnType2}:",
      "        try:",
      "            logger.info(\"${8:method_name_2} started\", {",
      "                \"${11:log_params_2}\"",
      "            })",
      "",
      "            # TODO: Implement service logic",
      "            ",
      "            result = ${12:result_2}",
      "            ",
      "            logger.info(\"${8:method_name_2} completed\", {",
      "                \"${13:result_log_2}\"",
      "            })",
      "",
      "            return result",
      "        except Exception as e:",
      "            logger.error(\"${8:method_name_2} failed\", {",
      "                \"error\": str(e),",
      "                \"${11:log_params_2}\"",
      "            })",
      "            raise"
    ],
    "description": "Create a service class with proper error handling and logging"
  },
  "Async Function": {
    "prefix": "async-func",
    "body": [
      "async def ${1:function_name}(${2:params}) -> ${3:ReturnType}:",
      "    try:",
      "        logger.info(\"${1:function_name} started\", {",
      "            \"${4:log_params}\"",
      "        })",
      "",
      "        # TODO: Implement async logic",
      "        ",
      "        result = ${5:result}",
      "        ",
      "        logger.info(\"${1:function_name} completed\", {",
      "            \"${6:result_log}\"",
      "        })",
      "",
      "        return result",
      "    except Exception as e:",
      "        logger.error(\"${1:function_name} failed\", {",
      "            \"error\": str(e),",
      "            \"${4:log_params}\"",
      "        })",
      "        raise"
    ],
    "description": "Create an async function with proper error handling and logging"
  },
  "Pydantic Model": {
    "prefix": "pydantic-model",
    "body": [
      "from pydantic import BaseModel, validator, Field",
      "from typing import Optional, List, Dict, Any",
      "from datetime import datetime",
      "import uuid",
      "",
      "class ${1:ModelName}(BaseModel):",
      "    id: Optional[str] = Field(default_factory=lambda: str(uuid.uuid4()))",
      "    ${2:fields}",
      "    created_at: Optional[datetime] = Field(default_factory=datetime.utcnow)",
      "    updated_at: Optional[datetime] = Field(default_factory=datetime.utcnow)",
      "",
      "    @validator('${3:field}')",
      "    def validate_${3:field}(cls, v):",
      "        if not v or len(v.strip()) < 3:",
      "            raise ValueError('${3:field} must be at least 3 characters')",
      "        return v.strip()",
      "",
      "    class Config:",
      "        json_encoders = {",
      "            datetime: lambda v: v.isoformat()",
      "        }",
      "",
      "class ${4:ModelName}Create(${1:ModelName}):",
      "    ${5:create_fields}",
      "",
      "class ${6:ModelName}Update(BaseModel):",
      "    ${7:update_fields}",
      "",
      "class ${8:ModelName}Response(${1:ModelName}):",
      "    ${9:response_fields}",
      "",
      "    class Config:",
      "        from_attributes = True"
    ],
    "description": "Create Pydantic models with validation and serialization"
  }
}
